// Generated by Sideko (sideko.dev)
#![recursion_limit = "1024"]
pub mod request_types;
pub mod schemas;
use request_types::*;
use reqwest::blocking::Client as ReqwestClient;
use reqwest::Error as ReqwestError;
use schemas::*;

#[derive(Clone, Debug)]
pub struct SidekoClient {
    pub client: ReqwestClient,
    pub base_url: String,
}

#[derive(Debug, thiserror::Error)]
pub enum CannotFormRequest {
    #[error("Invalid data provided: {input}")]
    InvalidArguments { input: String },
    #[error("Unknown error forming the request")]
    UnknownError { msg: String },
}

#[derive(Clone, Debug)]
pub struct ErrorResponse {
    pub status_code: u16,
    pub message: String,
}

#[derive(Clone, Debug)]
pub enum Error {
    CannotFormRequest,
    ErrorResponse(ErrorResponse),
}

impl SidekoClient {
    pub fn new(api_key: String) -> Result<Self, ReqwestError> {
        let base_url = "https://api.getpostman.com".to_string();

        let mut default_headers = reqwest::header::HeaderMap::new();
        // add key auth header
        default_headers.insert(
            "x-api-key",
            reqwest::header::HeaderValue::from_str(&api_key).expect("Must provide API key"),
        );

        let client = ReqwestClient::builder()
            .default_headers(default_headers)
            .build()?;

        Ok(Self {
            client,
            base_url,
            
        })
    }

    pub fn delete_api(&self, request: DeleteApisApiIdRequest) -> Result<serde_json::Value, Error> {
        let endpoint = format!("/apis/{}", request.api_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: serde_json::Value = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_schema_file(&self, request: DeleteApisApiIdSchemasSchemaIdFilesFilePathRequest) -> Result<serde_json::Value, Error> {
        let endpoint = format!("/apis/{}/schemas/{}/files/{}", request.api_id, request.schema_id, request.file_path);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: serde_json::Value = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_api_version(&self, request: DeleteApisApiIdVersionsVersionIdRequest) -> Result<serde_json::Value, Error> {
        let endpoint = format!("/apis/{}/versions/{}", request.api_id, request.version_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: serde_json::Value = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_collection(&self, request: DeleteCollectionsCollectionIdRequest) -> Result<DeleteCollectionsCollectionIdResponse, Error> {
        let endpoint = format!("/collections/{}", request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: DeleteCollectionsCollectionIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_collection_folder(&self, request: DeleteCollectionsCollectionIdFoldersFolderIdRequest) -> Result<DeleteCollectionsCollectionIdFoldersFolderIdResponse, Error> {
        let endpoint = format!("/collections/{}/folders/{}", request.collection_id, request.folder_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: DeleteCollectionsCollectionIdFoldersFolderIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_collection_request(&self, request: DeleteCollectionsCollectionIdRequestsRequestIdRequest) -> Result<DeleteCollectionsCollectionIdRequestsRequestIdResponse, Error> {
        let endpoint = format!("/collections/{}/requests/{}", request.collection_id, request.request_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: DeleteCollectionsCollectionIdRequestsRequestIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_collection_response(&self, request: DeleteCollectionsCollectionIdResponsesResponseIdRequest) -> Result<DeleteCollectionsCollectionIdResponsesResponseIdResponse, Error> {
        let endpoint = format!("/collections/{}/responses/{}", request.collection_id, request.response_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: DeleteCollectionsCollectionIdResponsesResponseIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_environment(&self, request: DeleteEnvironmentsEnvironmentIdRequest) -> Result<DeleteEnvironmentsEnvironmentIdResponse, Error> {
        let endpoint = format!("/environments/{}", request.environment_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: DeleteEnvironmentsEnvironmentIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_mock(&self, request: DeleteMocksMockIdRequest) -> Result<DeleteMocksMockIdResponse, Error> {
        let endpoint = format!("/mocks/{}", request.mock_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: DeleteMocksMockIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_mock_server_response(&self, request: DeleteMocksMockIdServerResponsesServerResponseIdRequest) -> Result<DeleteMocksMockIdServerResponsesServerResponseIdResponse, Error> {
        let endpoint = format!("/mocks/{}/server-responses/{}", request.mock_id, request.server_response_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: DeleteMocksMockIdServerResponsesServerResponseIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn unpublish_mock(&self, request: DeleteMocksMockIdUnpublishRequest) -> Result<DeleteMocksMockIdUnpublishResponse, Error> {
        let endpoint = format!("/mocks/{}/unpublish", request.mock_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: DeleteMocksMockIdUnpublishResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_monitor(&self, request: DeleteMonitorsMonitorIdRequest) -> Result<DeleteMonitorsMonitorIdResponse, Error> {
        let endpoint = format!("/monitors/{}", request.monitor_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: DeleteMonitorsMonitorIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn remove_element_or_folder(&self, request: DeleteNetworkPrivateElementTypeElementIdRequest) -> Result<DeleteNetworkPrivateElementTypeElementIdResponse, Error> {
        let endpoint = format!("/network/private/{}/{}", request.element_type, request.element_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: DeleteNetworkPrivateElementTypeElementIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_group(&self, request: DeleteScimV2GroupsGroupIdRequest) -> Result<serde_json::Value, Error> {
        let endpoint = format!("/scim/v2/Groups/{}", request.group_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: serde_json::Value = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn delete_workspace(&self, request: DeleteWorkspacesWorkspaceIdRequest) -> Result<DeleteWorkspacesWorkspaceIdResponse, Error> {
        let endpoint = format!("/workspaces/{}", request.workspace_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .delete(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: DeleteWorkspacesWorkspaceIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_all_apis(&self, request: GetApisRequest) -> Result<GetApisResponse, Error> {
        let endpoint = "/apis";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        query_params.push(("workspace_id", format!("{:?}", &request.workspace_id)));
        if let Some(created_by) = request.created_by {
            query_params.push(("created_by", format!("{:?}", &created_by)));
        }
        if let Some(cursor) = request.cursor {
            query_params.push(("cursor", format!("{:?}", &cursor)));
        }
        if let Some(description) = request.description {
            query_params.push(("description", format!("{:?}", &description)));
        }
        if let Some(limit) = request.limit {
            query_params.push(("limit", format!("{:?}", &limit)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetApisResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_an_api(&self, request: GetApisApiIdRequest) -> Result<serde_json::Value, Error> {
        let endpoint = format!("/apis/{}", request.api_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(include) = request.include {
            query_params.push(("include", format!("{:?}", &include)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: serde_json::Value = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_collection(&self, request: GetApisApiIdCollectionsCollectionIdRequest) -> Result<GetApisApiIdCollectionsCollectionIdResponse, Error> {
        let endpoint = format!("/apis/{}/collections/{}", request.api_id, request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(version_id) = request.version_id {
            query_params.push(("version_id", format!("{:?}", &version_id)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetApisApiIdCollectionsCollectionIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_schema(&self, request: GetApisApiIdSchemasSchemaIdRequest) -> Result<serde_json::Value, Error> {
        let endpoint = format!("/apis/{}/schemas/{}", request.api_id, request.schema_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(bundled) = request.bundled {
            query_params.push(("bundled", format!("{:?}", &bundled)));
        }
        if let Some(version_id) = request.version_id {
            query_params.push(("version_id", format!("{:?}", &version_id)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: serde_json::Value = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_schema_files(&self, request: GetApisApiIdSchemasSchemaIdFilesRequest) -> Result<GetApisApiIdSchemasSchemaIdFilesResponse, Error> {
        let endpoint = format!("/apis/{}/schemas/{}/files", request.api_id, request.schema_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(cursor) = request.cursor {
            query_params.push(("cursor", format!("{:?}", &cursor)));
        }
        if let Some(limit) = request.limit {
            query_params.push(("limit", format!("{:?}", &limit)));
        }
        if let Some(version_id) = request.version_id {
            query_params.push(("version_id", format!("{:?}", &version_id)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetApisApiIdSchemasSchemaIdFilesResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_schema_file_contents(&self, request: GetApisApiIdSchemasSchemaIdFilesFilePathRequest) -> Result<GetApisApiIdSchemasSchemaIdFilesFilePathResponse, Error> {
        let endpoint = format!("/apis/{}/schemas/{}/files/{}", request.api_id, request.schema_id, request.file_path);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(version_id) = request.version_id {
            query_params.push(("version_id", format!("{:?}", &version_id)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetApisApiIdSchemasSchemaIdFilesFilePathResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_api_tags(&self, request: GetApisApiIdTagsRequest) -> Result<GetApisApiIdTagsResponse, Error> {
        let endpoint = format!("/apis/{}/tags", request.api_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetApisApiIdTagsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_status_of_an_async_task(&self, request: GetApisApiIdTasksTaskIdRequest) -> Result<GetApisApiIdTasksTaskIdResponse, Error> {
        let endpoint = format!("/apis/{}/tasks/{}", request.api_id, request.task_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetApisApiIdTasksTaskIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_all_versions(&self, request: GetApisApiIdVersionsRequest) -> Result<GetApisApiIdVersionsResponse, Error> {
        let endpoint = format!("/apis/{}/versions", request.api_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(cursor) = request.cursor {
            query_params.push(("cursor", format!("{:?}", &cursor)));
        }
        if let Some(limit) = request.limit {
            query_params.push(("limit", format!("{:?}", &limit)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetApisApiIdVersionsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_api_version(&self, request: GetApisApiIdVersionsVersionIdRequest) -> Result<GetApisApiIdVersionsVersionIdResponse, Error> {
        let endpoint = format!("/apis/{}/versions/{}", request.api_id, request.version_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetApisApiIdVersionsVersionIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_audit_logs(&self, request: GetAuditLogsRequest) -> Result<GetAuditLogsResponse, Error> {
        let endpoint = "/audit/logs";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(cursor) = request.cursor {
            query_params.push(("cursor", format!("{:?}", &cursor)));
        }
        if let Some(limit) = request.limit {
            query_params.push(("limit", format!("{:?}", &limit)));
        }
        if let Some(order_by) = request.order_by {
            query_params.push(("order_by", format!("{:?}", &order_by)));
        }
        if let Some(since) = request.since {
            query_params.push(("since", format!("{:?}", &since)));
        }
        if let Some(until) = request.until {
            query_params.push(("until", format!("{:?}", &until)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetAuditLogsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn all_collections(&self, request: GetCollectionsRequest) -> Result<GetCollectionsResponse, Error> {
        let endpoint = "/collections";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(name) = request.name {
            query_params.push(("name", format!("{:?}", &name)));
        }
        if let Some(workspace_id) = request.workspace_id {
            query_params.push(("workspace_id", format!("{:?}", &workspace_id)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetCollectionsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn single_collection(&self, request: GetCollectionsCollectionIdRequest) -> Result<GetCollectionsCollectionIdResponse, Error> {
        let endpoint = format!("/collections/{}", request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(access_key) = request.access_key {
            query_params.push(("access_key", format!("{:?}", &access_key)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetCollectionsCollectionIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_collection_folder(&self, request: GetCollectionsCollectionIdFoldersFolderIdRequest) -> Result<GetCollectionsCollectionIdFoldersFolderIdResponse, Error> {
        let endpoint = format!("/collections/{}/folders/{}", request.collection_id, request.folder_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(ids) = request.ids {
            query_params.push(("ids", format!("{:?}", &ids)));
        }
        if let Some(populate) = request.populate {
            query_params.push(("populate", format!("{:?}", &populate)));
        }
        if let Some(uid) = request.uid {
            query_params.push(("uid", format!("{:?}", &uid)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetCollectionsCollectionIdFoldersFolderIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_collection_request(&self, request: GetCollectionsCollectionIdRequestsRequestIdRequest) -> Result<GetCollectionsCollectionIdRequestsRequestIdResponse, Error> {
        let endpoint = format!("/collections/{}/requests/{}", request.collection_id, request.request_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(ids) = request.ids {
            query_params.push(("ids", format!("{:?}", &ids)));
        }
        if let Some(populate) = request.populate {
            query_params.push(("populate", format!("{:?}", &populate)));
        }
        if let Some(uid) = request.uid {
            query_params.push(("uid", format!("{:?}", &uid)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetCollectionsCollectionIdRequestsRequestIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_collection_response(&self, request: GetCollectionsCollectionIdResponsesResponseIdRequest) -> Result<GetCollectionsCollectionIdResponsesResponseIdResponse, Error> {
        let endpoint = format!("/collections/{}/responses/{}", request.collection_id, request.response_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(ids) = request.ids {
            query_params.push(("ids", format!("{:?}", &ids)));
        }
        if let Some(populate) = request.populate {
            query_params.push(("populate", format!("{:?}", &populate)));
        }
        if let Some(uid) = request.uid {
            query_params.push(("uid", format!("{:?}", &uid)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetCollectionsCollectionIdResponsesResponseIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_collection_tags(&self, request: GetCollectionsCollectionIdTagsRequest) -> Result<GetCollectionsCollectionIdTagsResponse, Error> {
        let endpoint = format!("/collections/{}/tags", request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetCollectionsCollectionIdTagsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn transform_collection_to_open_api(&self, request: GetCollectionsCollectionIdTransformationsRequest) -> Result<GetCollectionsCollectionIdTransformationsResponse, Error> {
        let endpoint = format!("/collections/{}/transformations", request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetCollectionsCollectionIdTransformationsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_detected_secrets_locations(&self, request: GetDetectedSecretsSecretIdLocationsRequest) -> Result<GetDetectedSecretsSecretIdLocationsResponse, Error> {
        let endpoint = format!("/detected-secrets/{}/locations", request.secret_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        query_params.push(("workspace_id", format!("{:?}", &request.workspace_id)));
        if let Some(cursor) = request.cursor {
            query_params.push(("cursor", format!("{:?}", &cursor)));
        }
        if let Some(limit) = request.limit {
            query_params.push(("limit", format!("{:?}", &limit)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetDetectedSecretsSecretIdLocationsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn all_environments(&self, request: GetEnvironmentsRequest) -> Result<GetEnvironmentsResponse, Error> {
        let endpoint = "/environments";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(workspace_id) = request.workspace_id {
            query_params.push(("workspace_id", format!("{:?}", &workspace_id)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetEnvironmentsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn single_environment(&self, request: GetEnvironmentsEnvironmentIdRequest) -> Result<GetEnvironmentsEnvironmentIdResponse, Error> {
        let endpoint = format!("/environments/{}", request.environment_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetEnvironmentsEnvironmentIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn api_key_owner(&self) -> Result<GetMeResponse, Error> {
        let endpoint = "/me";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetMeResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_mocks(&self, request: GetMocksRequest) -> Result<GetMocksResponse, Error> {
        let endpoint = "/mocks";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(team_id) = request.team_id {
            query_params.push(("team_id", format!("{:?}", &team_id)));
        }
        if let Some(workspace) = request.workspace {
            query_params.push(("workspace", format!("{:?}", &workspace)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetMocksResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_mock(&self, request: GetMocksMockIdRequest) -> Result<GetMocksMockIdResponse, Error> {
        let endpoint = format!("/mocks/{}", request.mock_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetMocksMockIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_mock_call_logs(&self, request: GetMocksMockIdCallLogsRequest) -> Result<GetMocksMockIdCallLogsResponse, Error> {
        let endpoint = format!("/mocks/{}/call-logs", request.mock_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(cursor) = request.cursor {
            query_params.push(("cursor", format!("{:?}", &cursor)));
        }
        if let Some(direction) = request.direction {
            query_params.push(("direction", format!("{:?}", &direction)));
        }
        if let Some(include) = request.include {
            query_params.push(("include", format!("{:?}", &include)));
        }
        if let Some(limit) = request.limit {
            query_params.push(("limit", format!("{:?}", &limit)));
        }
        if let Some(request_method) = request.request_method {
            query_params.push(("request_method", format!("{:?}", &request_method)));
        }
        if let Some(request_path) = request.request_path {
            query_params.push(("request_path", format!("{:?}", &request_path)));
        }
        if let Some(response_status_code) = request.response_status_code {
            query_params.push(("response_status_code", format!("{:?}", &response_status_code)));
        }
        if let Some(response_type) = request.response_type {
            query_params.push(("response_type", format!("{:?}", &response_type)));
        }
        if let Some(since) = request.since {
            query_params.push(("since", format!("{:?}", &since)));
        }
        if let Some(sort) = request.sort {
            query_params.push(("sort", format!("{:?}", &sort)));
        }
        if let Some(until) = request.until {
            query_params.push(("until", format!("{:?}", &until)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetMocksMockIdCallLogsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_mock_server_responses(&self, request: GetMocksMockIdServerResponsesRequest) -> Result<Vec<GetMocksMockIdServerResponsesResponseItem>, Error> {
        let endpoint = format!("/mocks/{}/server-responses", request.mock_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: Vec<GetMocksMockIdServerResponsesResponseItem> = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_mock_server_response(&self, request: GetMocksMockIdServerResponsesServerResponseIdRequest) -> Result<Vec<GetMocksMockIdServerResponsesServerResponseIdResponseItem>, Error> {
        let endpoint = format!("/mocks/{}/server-responses/{}", request.mock_id, request.server_response_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: Vec<GetMocksMockIdServerResponsesServerResponseIdResponseItem> = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn all_monitors(&self, request: GetMonitorsRequest) -> Result<GetMonitorsResponse, Error> {
        let endpoint = "/monitors";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(workspace) = request.workspace {
            query_params.push(("workspace", format!("{:?}", &workspace)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetMonitorsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn single_monitor(&self, request: GetMonitorsMonitorIdRequest) -> Result<GetMonitorsMonitorIdResponse, Error> {
        let endpoint = format!("/monitors/{}", request.monitor_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetMonitorsMonitorIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_all_elements_and_folders(&self, request: GetNetworkPrivateRequest) -> Result<GetNetworkPrivateResponse, Error> {
        let endpoint = "/network/private";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(added_by) = request.added_by {
            query_params.push(("added_by", format!("{:?}", &added_by)));
        }
        if let Some(created_by) = request.created_by {
            query_params.push(("created_by", format!("{:?}", &created_by)));
        }
        if let Some(description) = request.description {
            query_params.push(("description", format!("{:?}", &description)));
        }
        if let Some(direction) = request.direction {
            query_params.push(("direction", format!("{:?}", &direction)));
        }
        if let Some(limit) = request.limit {
            query_params.push(("limit", format!("{:?}", &limit)));
        }
        if let Some(name) = request.name {
            query_params.push(("name", format!("{:?}", &name)));
        }
        if let Some(offset) = request.offset {
            query_params.push(("offset", format!("{:?}", &offset)));
        }
        if let Some(parent_folder_id) = request.parent_folder_id {
            query_params.push(("parent_folder_id", format!("{:?}", &parent_folder_id)));
        }
        if let Some(since) = request.since {
            query_params.push(("since", format!("{:?}", &since)));
        }
        if let Some(sort) = request.sort {
            query_params.push(("sort", format!("{:?}", &sort)));
        }
        if let Some(summary) = request.summary {
            query_params.push(("summary", format!("{:?}", &summary)));
        }
        if let Some(type_field) = request.type_field {
            query_params.push(("type", format!("{:?}", &type_field)));
        }
        if let Some(until) = request.until {
            query_params.push(("until", format!("{:?}", &until)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetNetworkPrivateResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_all_add_element_requests(&self, request: GetNetworkPrivateNetworkEntityRequestAllRequest) -> Result<GetNetworkPrivateNetworkEntityRequestAllResponse, Error> {
        let endpoint = "/network/private/network-entity/request/all";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(direction) = request.direction {
            query_params.push(("direction", format!("{:?}", &direction)));
        }
        if let Some(limit) = request.limit {
            query_params.push(("limit", format!("{:?}", &limit)));
        }
        if let Some(name) = request.name {
            query_params.push(("name", format!("{:?}", &name)));
        }
        if let Some(offset) = request.offset {
            query_params.push(("offset", format!("{:?}", &offset)));
        }
        if let Some(requested_by) = request.requested_by {
            query_params.push(("requested_by", format!("{:?}", &requested_by)));
        }
        if let Some(since) = request.since {
            query_params.push(("since", format!("{:?}", &since)));
        }
        if let Some(sort) = request.sort {
            query_params.push(("sort", format!("{:?}", &sort)));
        }
        if let Some(status) = request.status {
            query_params.push(("status", format!("{:?}", &status)));
        }
        if let Some(type_field) = request.type_field {
            query_params.push(("type", format!("{:?}", &type_field)));
        }
        if let Some(until) = request.until {
            query_params.push(("until", format!("{:?}", &until)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetNetworkPrivateNetworkEntityRequestAllResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn fetch_all_group_resources(&self, request: GetScimV2GroupsRequest) -> Result<GetScimV2GroupsResponse, Error> {
        let endpoint = "/scim/v2/Groups";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(count) = request.count {
            query_params.push(("count", format!("{:?}", &count)));
        }
        if let Some(filter) = request.filter {
            query_params.push(("filter", format!("{:?}", &filter)));
        }
        if let Some(start_index) = request.start_index {
            query_params.push(("start_index", format!("{:?}", &start_index)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetScimV2GroupsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn fetch_group_resource(&self, request: GetScimV2GroupsGroupIdRequest) -> Result<GetScimV2GroupsGroupIdResponse, Error> {
        let endpoint = format!("/scim/v2/Groups/{}", request.group_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetScimV2GroupsGroupIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_resource_types(&self) -> Result<Vec<GetScimV2ResourceTypesResponseItem>, Error> {
        let endpoint = "/scim/v2/ResourceTypes";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: Vec<GetScimV2ResourceTypesResponseItem> = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn service_provider_config(&self) -> Result<GetScimV2ServiceProviderConfigResponse, Error> {
        let endpoint = "/scim/v2/ServiceProviderConfig";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetScimV2ServiceProviderConfigResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn fetch_all_user_resources(&self, request: GetScimV2UsersRequest) -> Result<GetScimV2UsersResponse, Error> {
        let endpoint = "/scim/v2/Users";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(count) = request.count {
            query_params.push(("count", format!("{:?}", &count)));
        }
        if let Some(filter) = request.filter {
            query_params.push(("filter", format!("{:?}", &filter)));
        }
        if let Some(start_index) = request.start_index {
            query_params.push(("start_index", format!("{:?}", &start_index)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetScimV2UsersResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn fetch_user_resource(&self, request: GetScimV2UsersUserIdRequest) -> Result<GetScimV2UsersUserIdResponse, Error> {
        let endpoint = format!("/scim/v2/Users/{}", request.user_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetScimV2UsersUserIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_secret_types(&self) -> Result<GetSecretTypesResponse, Error> {
        let endpoint = "/secret-types";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetSecretTypesResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_tagged_entities(&self, request: GetTagsSlugEntitiesRequest) -> Result<GetTagsSlugEntitiesResponse, Error> {
        let endpoint = format!("/tags/{}/entities", request.slug);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(cursor) = request.cursor {
            query_params.push(("cursor", format!("{:?}", &cursor)));
        }
        if let Some(direction) = request.direction {
            query_params.push(("direction", format!("{:?}", &direction)));
        }
        if let Some(entity_type) = request.entity_type {
            query_params.push(("entity_type", format!("{:?}", &entity_type)));
        }
        if let Some(limit) = request.limit {
            query_params.push(("limit", format!("{:?}", &limit)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetTagsSlugEntitiesResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn all_workspaces(&self, request: GetWorkspacesRequest) -> Result<GetWorkspacesResponse, Error> {
        let endpoint = "/workspaces";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(type_field) = request.type_field {
            query_params.push(("type", format!("{:?}", &type_field)));
        }
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetWorkspacesResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn single_workspace(&self, request: GetWorkspacesWorkspaceIdRequest) -> Result<GetWorkspacesWorkspaceIdResponse, Error> {
        let endpoint = format!("/workspaces/{}", request.workspace_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetWorkspacesWorkspaceIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_workspace_global_variables(&self, request: GetWorkspacesWorkspaceIdGlobalVariablesRequest) -> Result<GetWorkspacesWorkspaceIdGlobalVariablesResponse, Error> {
        let endpoint = format!("/workspaces/{}/global-variables", request.workspace_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetWorkspacesWorkspaceIdGlobalVariablesResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn get_workspace_tags(&self, request: GetWorkspacesWorkspaceIdTagsRequest) -> Result<GetWorkspacesWorkspaceIdTagsResponse, Error> {
        let endpoint = format!("/workspaces/{}/tags", request.workspace_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .get(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: GetWorkspacesWorkspaceIdTagsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn patch_collection(&self, request: PatchCollectionsCollectionIdRequest) -> Result<PatchCollectionsCollectionIdResponse, Error> {
        let endpoint = format!("/collections/{}", request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .patch(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PatchCollectionsCollectionIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn patch_scim_v2_groups_group_id(&self, request: PatchScimV2GroupsGroupIdRequest) -> Result<PatchScimV2GroupsGroupIdResponse, Error> {
        let endpoint = format!("/scim/v2/Groups/{}", request.group_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .patch(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PatchScimV2GroupsGroupIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_user_state(&self, request: PatchScimV2UsersUserIdRequest) -> Result<PatchScimV2UsersUserIdResponse, Error> {
        let endpoint = format!("/scim/v2/Users/{}", request.user_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .patch(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PatchScimV2UsersUserIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_api(&self, request: PostApisRequest) -> Result<PostApisResponse, Error> {
        let endpoint = "/apis";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        query_params.push(("workspace_id", format!("{:?}", &request.workspace_id)));
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostApisResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn add_collection(&self, request: PostApisApiIdCollectionsRequest) -> Result<PostApisApiIdCollectionsResponse, Error> {
        let endpoint = format!("/apis/{}/collections", request.api_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostApisApiIdCollectionsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_api_schema(&self, request: PostApisApiIdSchemasRequest) -> Result<PostApisApiIdSchemasResponse, Error> {
        let endpoint = format!("/apis/{}/schemas", request.api_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostApisApiIdSchemasResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_api_version(&self, request: PostApisApiIdVersionsRequest) -> Result<PostApisApiIdVersionsResponse, Error> {
        let endpoint = format!("/apis/{}/versions", request.api_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostApisApiIdVersionsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_collection(&self, request: PostCollectionsRequest) -> Result<PostCollectionsResponse, Error> {
        let endpoint = "/collections";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(workspace_id) = request.workspace_id {
            query_params.push(("workspace_id", format!("{:?}", &workspace_id)));
        }
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostCollectionsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_a_fork(&self, request: PostCollectionsForkCollectionIdRequest) -> Result<PostCollectionsForkCollectionIdResponse, Error> {
        let endpoint = format!("/collections/fork/{}", request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        query_params.push(("workspace", format!("{:?}", &request.workspace)));
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostCollectionsForkCollectionIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn merge_a_fork(&self, request: PostCollectionsMergeRequest) -> Result<PostCollectionsMergeResponse, Error> {
        let endpoint = "/collections/merge";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostCollectionsMergeResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_collection_folder(&self, request: PostCollectionsCollectionIdFoldersRequest) -> Result<PostCollectionsCollectionIdFoldersResponse, Error> {
        let endpoint = format!("/collections/{}/folders", request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostCollectionsCollectionIdFoldersResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_collection_request(&self, request: PostCollectionsCollectionIdRequestsRequest) -> Result<PostCollectionsCollectionIdRequestsResponse, Error> {
        let endpoint = format!("/collections/{}/requests", request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(folder_id) = request.folder_id {
            query_params.push(("folder_id", format!("{:?}", &folder_id)));
        }
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostCollectionsCollectionIdRequestsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_collection_response(&self, request: PostCollectionsCollectionIdResponsesRequest) -> Result<PostCollectionsCollectionIdResponsesResponse, Error> {
        let endpoint = format!("/collections/{}/responses", request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        query_params.push(("request_id", format!("{:?}", &request.request_id)));
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostCollectionsCollectionIdResponsesResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn detected_secrets_queries(&self, request: PostDetectedSecretsQueriesRequest) -> Result<PostDetectedSecretsQueriesResponse, Error> {
        let endpoint = "/detected-secrets-queries";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(cursor) = request.cursor {
            query_params.push(("cursor", format!("{:?}", &cursor)));
        }
        if let Some(include) = request.include {
            query_params.push(("include", format!("{:?}", &include)));
        }
        if let Some(limit) = request.limit {
            query_params.push(("limit", format!("{:?}", &limit)));
        }
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostDetectedSecretsQueriesResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_environment(&self, request: PostEnvironmentsRequest) -> Result<PostEnvironmentsResponse, Error> {
        let endpoint = "/environments";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(workspace_id) = request.workspace_id {
            query_params.push(("workspace_id", format!("{:?}", &workspace_id)));
        }
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostEnvironmentsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn import_external_api_specification(&self, request: PostImportOpenapiRequest) -> Result<PostImportOpenapiResponse, Error> {
        let endpoint = "/import/openapi";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(workspace_id) = request.workspace_id {
            query_params.push(("workspace_id", format!("{:?}", &workspace_id)));
        }
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostImportOpenapiResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_mock(&self, request: PostMocksRequest) -> Result<PostMocksResponse, Error> {
        let endpoint = "/mocks";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(workspace_id) = request.workspace_id {
            query_params.push(("workspace_id", format!("{:?}", &workspace_id)));
        }
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostMocksResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn publish_mock(&self, request: PostMocksMockIdPublishRequest) -> Result<PostMocksMockIdPublishResponse, Error> {
        let endpoint = format!("/mocks/{}/publish", request.mock_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .post(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostMocksMockIdPublishResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_server_response(&self, request: PostMocksMockIdServerResponsesRequest) -> Result<Vec<PostMocksMockIdServerResponsesResponseItem>, Error> {
        let endpoint = format!("/mocks/{}/server-responses", request.mock_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: Vec<PostMocksMockIdServerResponsesResponseItem> = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_monitor(&self, request: PostMonitorsRequest) -> Result<PostMonitorsResponse, Error> {
        let endpoint = "/monitors";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(workspace_id) = request.workspace_id {
            query_params.push(("workspace_id", format!("{:?}", &workspace_id)));
        }
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostMonitorsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn run_a_monitor(&self, request: PostMonitorsMonitorIdRunRequest) -> Result<PostMonitorsMonitorIdRunResponse, Error> {
        let endpoint = format!("/monitors/{}/run", request.monitor_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .post(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostMonitorsMonitorIdRunResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn post_element_or_folder(&self, request: PostNetworkPrivateRequest) -> Result<serde_json::Value, Error> {
        let endpoint = "/network/private";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: serde_json::Value = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_group(&self, request: PostScimV2GroupsRequest) -> Result<PostScimV2GroupsResponse, Error> {
        let endpoint = "/scim/v2/Groups";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostScimV2GroupsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_user(&self, request: PostScimV2UsersRequest) -> Result<PostScimV2UsersResponse, Error> {
        let endpoint = "/scim/v2/Users";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostScimV2UsersResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn schema_security_validation(&self, request: PostSecurityApiValidationRequest) -> Result<PostSecurityApiValidationResponse, Error> {
        let endpoint = "/security/api-validation";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostSecurityApiValidationResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_webhook(&self, request: PostWebhooksRequest) -> Result<PostWebhooksResponse, Error> {
        let endpoint = "/webhooks";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        if let Some(workspace_id) = request.workspace_id {
            query_params.push(("workspace_id", format!("{:?}", &workspace_id)));
        }
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostWebhooksResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_workspace(&self, request: PostWorkspacesRequest) -> Result<PostWorkspacesResponse, Error> {
        let endpoint = "/workspaces";
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .post(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PostWorkspacesResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_an_api(&self, request: PutApisApiIdRequest) -> Result<PutApisApiIdResponse, Error> {
        let endpoint = format!("/apis/{}", request.api_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutApisApiIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn sync_collection_with_schema(&self, request: PutApisApiIdCollectionsCollectionIdSyncWithSchemaTasksRequest) -> Result<PutApisApiIdCollectionsCollectionIdSyncWithSchemaTasksResponse, Error> {
        let endpoint = format!("/apis/{}/collections/{}/sync-with-schema-tasks", request.api_id, request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let response = self
            .client
            .put(url)
            .query(&query_params)
            
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutApisApiIdCollectionsCollectionIdSyncWithSchemaTasksResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn create_or_update_schema_file(&self, request: PutApisApiIdSchemasSchemaIdFilesFilePathRequest) -> Result<PutApisApiIdSchemasSchemaIdFilesFilePathResponse, Error> {
        let endpoint = format!("/apis/{}/schemas/{}/files/{}", request.api_id, request.schema_id, request.file_path);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutApisApiIdSchemasSchemaIdFilesFilePathResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_api_tags(&self, request: PutApisApiIdTagsRequest) -> Result<PutApisApiIdTagsResponse, Error> {
        let endpoint = format!("/apis/{}/tags", request.api_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutApisApiIdTagsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_api_version(&self, request: PutApisApiIdVersionsVersionIdRequest) -> Result<PutApisApiIdVersionsVersionIdResponse, Error> {
        let endpoint = format!("/apis/{}/versions/{}", request.api_id, request.version_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutApisApiIdVersionsVersionIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn put_collection(&self, request: PutCollectionsCollectionIdRequest) -> Result<PutCollectionsCollectionIdResponse, Error> {
        let endpoint = format!("/collections/{}", request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutCollectionsCollectionIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_collection_folder(&self, request: PutCollectionsCollectionIdFoldersFolderIdRequest) -> Result<PutCollectionsCollectionIdFoldersFolderIdResponse, Error> {
        let endpoint = format!("/collections/{}/folders/{}", request.collection_id, request.folder_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutCollectionsCollectionIdFoldersFolderIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_collection_request(&self, request: PutCollectionsCollectionIdRequestsRequestIdRequest) -> Result<PutCollectionsCollectionIdRequestsRequestIdResponse, Error> {
        let endpoint = format!("/collections/{}/requests/{}", request.collection_id, request.request_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutCollectionsCollectionIdRequestsRequestIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_collection_response(&self, request: PutCollectionsCollectionIdResponsesResponseIdRequest) -> Result<PutCollectionsCollectionIdResponsesResponseIdResponse, Error> {
        let endpoint = format!("/collections/{}/responses/{}", request.collection_id, request.response_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutCollectionsCollectionIdResponsesResponseIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_collection_tags(&self, request: PutCollectionsCollectionIdTagsRequest) -> Result<PutCollectionsCollectionIdTagsResponse, Error> {
        let endpoint = format!("/collections/{}/tags", request.collection_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutCollectionsCollectionIdTagsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_detected_secret_resolutions(&self, request: PutDetectedSecretsSecretIdRequest) -> Result<PutDetectedSecretsSecretIdResponse, Error> {
        let endpoint = format!("/detected-secrets/{}", request.secret_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutDetectedSecretsSecretIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_environment(&self, request: PutEnvironmentsEnvironmentIdRequest) -> Result<PutEnvironmentsEnvironmentIdResponse, Error> {
        let endpoint = format!("/environments/{}", request.environment_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutEnvironmentsEnvironmentIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_mock(&self, request: PutMocksMockIdRequest) -> Result<PutMocksMockIdResponse, Error> {
        let endpoint = format!("/mocks/{}", request.mock_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutMocksMockIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_server_response(&self, request: PutMocksMockIdServerResponsesServerResponseIdRequest) -> Result<Vec<PutMocksMockIdServerResponsesServerResponseIdResponseItem>, Error> {
        let endpoint = format!("/mocks/{}/server-responses/{}", request.mock_id, request.server_response_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: Vec<PutMocksMockIdServerResponsesServerResponseIdResponseItem> = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_monitor(&self, request: PutMonitorsMonitorIdRequest) -> Result<PutMonitorsMonitorIdResponse, Error> {
        let endpoint = format!("/monitors/{}", request.monitor_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutMonitorsMonitorIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn respond_element_add_request(&self, request: PutNetworkPrivateNetworkEntityRequestRequestIdRequest) -> Result<PutNetworkPrivateNetworkEntityRequestRequestIdResponse, Error> {
        let endpoint = format!("/network/private/network-entity/request/{}", request.request_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutNetworkPrivateNetworkEntityRequestRequestIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn put_element_or_folder(&self, request: PutNetworkPrivateElementTypeElementIdRequest) -> Result<serde_json::Value, Error> {
        let endpoint = format!("/network/private/{}/{}", request.element_type, request.element_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: serde_json::Value = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_user_information(&self, request: PutScimV2UsersUserIdRequest) -> Result<PutScimV2UsersUserIdResponse, Error> {
        let endpoint = format!("/scim/v2/Users/{}", request.user_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutScimV2UsersUserIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_workspace(&self, request: PutWorkspacesWorkspaceIdRequest) -> Result<PutWorkspacesWorkspaceIdResponse, Error> {
        let endpoint = format!("/workspaces/{}", request.workspace_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutWorkspacesWorkspaceIdResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn put_workspace_global_variables(&self, request: PutWorkspacesWorkspaceIdGlobalVariablesRequest) -> Result<PutWorkspacesWorkspaceIdGlobalVariablesResponse, Error> {
        let endpoint = format!("/workspaces/{}/global-variables", request.workspace_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutWorkspacesWorkspaceIdGlobalVariablesResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }
    pub fn update_workspace_tags(&self, request: PutWorkspacesWorkspaceIdTagsRequest) -> Result<PutWorkspacesWorkspaceIdTagsResponse, Error> {
        let endpoint = format!("/workspaces/{}/tags", request.workspace_id);
        let url = format!("{}{}", self.base_url, endpoint);

        let mut query_params: Vec<(&str, String)> = vec![];
        
        let request_body: serde_json::Value = serde_json::to_value(request.data).unwrap();
        let response = self
            .client
            .put(url)
            .query(&query_params)
            .json(&request_body)
            .send()
            .unwrap();
        
        if response.status().is_success() {
            let response: PutWorkspacesWorkspaceIdTagsResponse = response.json().unwrap();
            Ok(response)
        } else {
            let status_code = response.status().as_u16();
            let message = response.text().unwrap_or_default();
            let err = ErrorResponse { status_code, message };
            Err(Error::ErrorResponse(err))
        }
    }

}
